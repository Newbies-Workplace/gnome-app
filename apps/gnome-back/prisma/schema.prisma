generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "linux-musl-openssl-3.0.x"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                   String                @id @unique @default(uuid())
  googleId             String
  name                 String
  email                String
  pictureUrl           String
  inviteCode           String                @unique
  Team                 Team?
  role                 UserRole              @default(USER)
  Resource             UserResource?
  gnomeInteractions    GnomeInteraction[]
  sentRequest          Friendship[]          @relation("sender")
  receivedRequest      Friendship[]          @relation("receiver")
  buildings            Building[]
  buildingsInteraction BuildingInteraction[]
  achievements    UserAchievement[]
}

model UserResource {
  berries Int?   @default(0)
  sticks Int?   @default(0)
  stones Int?   @default(0)
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId String @id @unique
}

model Gnome {
  id           String             @id @unique @default(uuid())
  name         String
  funFact      String
  latitude     Float
  longitude    Float
  location     String
  creationDate DateTime
  description  String
  exists       Boolean            @default(true)
  pictureUrl   String
  interactions GnomeInteraction[]
  districtId   Int?
  district     District?          @relation(fields: [districtId], references: [id])
}

model Achievement {
  id           String            @id @unique @default(uuid())
  name         String
  description  String
  pictureUrl   String
  users        UserAchievement[]
}

model UserAchievement {
  @@id([userId, achievementId])
  userId         String
  achievementId  String
  earnedAt       DateTime      @default(now())
  user           User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  achievement    Achievement   @relation(fields: [achievementId], references: [id])
}

model Report {
  id           String @id @unique @default(cuid())
  gnomeName    String
  pictureUrl   String
  latitude     Float
  longitude    Float
  location     String
  reportAuthor String
}

model GnomeInteraction {
  id              String   @id @unique @default(uuid())
  user            User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  gnome           Gnome    @relation(fields: [gnomeId], references: [id], onDelete: Cascade)
  interactionDate DateTime
  userId          String
  gnomeId         String
}

model Friendship {
  id         String @id @unique @default(cuid())
  sender     User   @relation("sender", fields: [senderId], references: [id], onDelete: Cascade)
  receiver   User   @relation("receiver", fields: [receiverId], references: [id], onDelete: Cascade)
  senderId   String
  receiverId String
}

model Building {
  id         String       @id @unique @default(cuid())
  gnomeCount Int
  Health     Int
  latitude   Float
  longitude  Float
  District   String
  Type       BuildingType
  createdAt  DateTime     @default(now())
  Owner      User         @relation(fields: [ownerId], references: [id], onDelete: Cascade)
  ownerId    String
}

model BuildingInteraction {
  id              String                  @id @unique @default(cuid())
  interactionType BuildingInteractionType
  user            User                    @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId          String
  createdAt       DateTime                @default(now())
  amount          Int // ilosc surowcow przy wzmocnieniu/ilosc gnomow przy ataku
}

enum BuildingType {
  WATCHTOWER
  MINE
}

enum BuildingInteractionType {
  ATTACK
  EMPOWER
}

model District {
  id     Int     @id @default(autoincrement())
  name   String
  points Json
  minX   Float
  maxX   Float
  minY   Float
  maxY   Float
  gnomes Gnome[]
}

enum UserRole {
  ADMIN
  USER
  MODERATOR
}

enum Status {
  ACTIVE
  PENDING
}

enum Team {
  TEAM1
  TEAM2
  TEAM3
}
